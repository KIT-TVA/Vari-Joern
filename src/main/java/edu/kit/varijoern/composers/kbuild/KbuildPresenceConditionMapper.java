package edu.kit.varijoern.composers.kbuild;

import edu.kit.varijoern.composers.PresenceConditionMapper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.prop4j.And;
import org.prop4j.Node;

import java.nio.file.Path;
import java.util.Map;
import java.util.Optional;

/**
 * Determines the presence conditions of individual code lines in a file generated by {@link KbuildComposer}.
 */
public class KbuildPresenceConditionMapper implements PresenceConditionMapper {
    private static final Logger LOGGER = LogManager.getLogger();
    private final FilePresenceConditionMapper filePresenceConditionMapper;
    private final Map<Path, LinePresenceConditionMapper> linePresenceConditionMappers;
    private final Map<Path, GenerationInformation> generationInformation;

    /**
     * Creates a new {@link KbuildPresenceConditionMapper} with the specified information.
     *
     * @param filePresenceConditionMapper  a file presence condition mapper for the original files
     * @param linePresenceConditionMappers the {@link LinePresenceConditionMapper}s for the individual files. This list
     *                                     should contain an entry for all files for which the composer detected a GCC
     *                                     call. The keys are the paths to the files generated by the composer, relative
     *                                     to the output directory.
     * @param generationInformation        a map from paths of generated files to information about the generation
     *                                     process. The keys are the paths to the files generated by the composer,
     *                                     relative to the output directory.
     */
    public KbuildPresenceConditionMapper(FilePresenceConditionMapper filePresenceConditionMapper,
                                         Map<Path, LinePresenceConditionMapper> linePresenceConditionMappers,
                                         Map<Path, GenerationInformation> generationInformation) {
        this.filePresenceConditionMapper = filePresenceConditionMapper;
        this.linePresenceConditionMappers = linePresenceConditionMappers;
        this.generationInformation = generationInformation;
    }

    @Override
    public Optional<Node> getPresenceCondition(Path file, int lineNumber) {
        Path normalizedFilePath = file.normalize();
        GenerationInformation fileGenerationInformation = this.generationInformation.get(normalizedFilePath);
        if (fileGenerationInformation == null) {
            LOGGER.warn("Could not find generation information for file {}", normalizedFilePath);
            return Optional.empty();
        }
        Path originalPath = fileGenerationInformation.originalPath();
        Path originalPathToObjectFile = originalPath.getParent().resolve(
                originalPath.getFileName().toString().replaceAll("\\.[a-zA-Z0-9]+$", ".o")
        );
        Optional<Node> filePresenceCondition = this.filePresenceConditionMapper
                .getPresenceCondition(originalPathToObjectFile.normalize());
        if (filePresenceCondition.isEmpty())
            return Optional.empty();
        LinePresenceConditionMapper linePresenceConditionMapper = this.linePresenceConditionMappers
                .get(normalizedFilePath);
        if (linePresenceConditionMapper == null)
            return Optional.empty();

        return linePresenceConditionMapper.getPresenceCondition(lineNumber)
                .map(linePresenceCondition -> new And(filePresenceCondition.get(), linePresenceCondition));
    }
}
